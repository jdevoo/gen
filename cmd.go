package main

import (
	"flag"
	"fmt"
	"io"
	"os"
	"os/signal"
	"runtime"
	"syscall"
)

// Version information, populated by make
// Token count accumulator in case of CTRL-C
// Parameter map shared with tools
var (
	version    string
	golang     string
	githash    string
	tokenCount int32
	keyVals    ParamMap
)

const (
	siExt     = ".sprompt"
	pExt      = ".prompt"
	embModel  = "text-embedding-004"
	digestKey = "{digest}"
)

// Flags struct to hold gen option values
type Flags struct {
	ChatMode          bool
	Code              bool
	DigestPaths       ParamArray
	Embed             bool
	FilePaths         ParamArray
	GenModel          string
	Help              bool
	JSON              bool
	K                 int
	Lambda            float64
	OnlyKvs           bool
	Stdin             bool
	SystemInstruction bool
	TokenCount        bool
	Temp              float64
	Tool              bool
	TopP              float64
	Unsafe            bool
	Verbose           bool
	Version           bool
}

func main() {
	// Define parameter map.
	keyVals = ParamMap{}

	// Define flags.
	flags := &Flags{}
	flag.BoolVar(&flags.Verbose, "V", false, "output model details, system instructions and chat history")
	flag.BoolVar(&flags.ChatMode, "c", false, "enter chat mode after content generation")
	flag.BoolVar(&flags.Code, "code", false, "allow code execution (incompatible with -json and -tool)")
	flag.Var(&flags.DigestPaths, "d", "path to a digest folder")
	flag.BoolVar(&flags.Embed, "e", false, fmt.Sprintf("write embeddings to digest (default model \"%s\")", embModel))
	flag.Var(&flags.FilePaths, "f", "file or quoted files matching pattern to attach")
	flag.BoolVar(&flags.Help, "h", false, "show this help message and exit")
	flag.BoolVar(&flags.JSON, "json", false, "response in JavaScript Object Notation (incompatible with -tool and -code)")
	flag.IntVar(&flags.K, "k", 3, "maximum number of entries from digest to retrieve")
	flag.Float64Var(&flags.Lambda, "l", 0.5, "trade off accuracy for diversity when querying digests [0.0,1.0]")
	flag.StringVar(&flags.GenModel, "m", "gemini-2.0-flash", "embedding or generative model name")
	flag.BoolVar(&flags.OnlyKvs, "o", false, "only store metadata with embeddings and ignore the content")
	flag.Var(&keyVals, "p", "prompt parameter value in format key=val")
	flag.BoolVar(&flags.SystemInstruction, "s", false, "treat argument as system instruction")
	flag.BoolVar(&flags.TokenCount, "t", false, "output total number of tokens")
	flag.Float64Var(&flags.Temp, "temp", 1.0, "changes sampling during response generation [0.0,2.0]")
	flag.BoolVar(&flags.Tool, "tool", false, "invoke one of the tools (incompatible with -json and -code)")
	flag.Float64Var(&flags.TopP, "top_p", 0.95, "changes how the model selects tokens for generation [0.0,1.0]")
	flag.BoolVar(&flags.Unsafe, "unsafe", false, "force generation when gen aborts with FinishReasonSafety")
	flag.BoolVar(&flags.Version, "v", false, "show version and exit")
	flag.Parse()
	flags.Stdin = hasInputFromStdin(os.Stdin)

	// Handle help and version flags before any further processing
	if flags.Help {
		emitUsage(os.Stdout)
		os.Exit(0)
	}
	if flags.Version {
		fmt.Fprintf(os.Stdout, "gen version %s (%s %s)\n", version, golang, githash)
		os.Exit(0)
	}

	// Argument validation
	if !isValidFlagSet(flags) {
		emitUsage(os.Stderr)
		os.Exit(1)
	}

	// Handle token count as separate Go routine
	done := make(chan os.Signal, 1)
	signal.Notify(done, os.Interrupt, syscall.SIGTERM)
	go func() {
		<-done
		if tokenCount > 0 {
			fmt.Printf("\n\033[31m%d tokens\033[0m\n", tokenCount)
		}
		os.Exit(1)
	}()

	os.Exit(emitGen(os.Stdin, os.Stdout, flags))
}

// Usage overrides PrintDefaults to provide custom usage information.
func emitUsage(out io.Writer) {
	fmt.Fprintln(out, "Usage: gen [options] <prompt>")
	fmt.Fprintf(out, "\n")
	fmt.Fprintln(out, "Command-line interface to Google Gemini large language models")
	fmt.Fprintln(out, "  Requires a valid GEMINI_API_KEY environment variable set.")
	fmt.Fprintln(out, "  Content is generated by a prompt and optional system instructions.")
	fmt.Fprintln(out, "  Use - to assign stdin as prompt argument or as attached file.")
	fmt.Fprintf(out, "\n")
	fmt.Fprintln(out, "Tools:")
	fmt.Fprintln(out, knownTools())
	fmt.Fprintf(out, "\n")
	fmt.Fprintln(out, "Options:")
	fmt.Fprintf(out, "\n")
	flag.PrintDefaults()
}

func isValidFlagSet(flags *Flags) bool {
	// Handle invalid arguments/option combinations, starting with no embed flag, prompt as stdin, argument or file
	if (!flags.Embed && !flags.Stdin && len(flag.Args()) == 0 && !oneMatches(flags.FilePaths, pExt) && !oneMatches(flags.FilePaths, siExt)) ||
		// embeddings with chat, prompts, no files, no argument or various generative settings
		(flags.Embed && (flags.ChatMode || flags.Unsafe || flags.Code || flags.Tool || flags.JSON ||
			len(flags.DigestPaths) != 1 ||
			(flags.OnlyKvs && len(keyVals) == 0) ||
			isFlagSet("temp") || isFlagSet("top_p") || isFlagSet("k") || isFlagSet("l") ||
			anyMatches(flags.FilePaths, pExt) || anyMatches(flags.FilePaths, siExt) ||
			(len(flag.Args()) == 0 && !oneMatches(flags.FilePaths, "-")))) ||
		// simultaneous use of -code and -tool
		(flags.Code && flags.Tool) ||
		// tool registration with json output
		(flags.Tool && flags.JSON) ||
		// code execution with json output
		(flags.Code && flags.JSON) ||
		// invalid k values
		(flags.K < 0 || flags.K > 10) ||
		// invalid lambda values
		(flags.Lambda < 0 || flags.Lambda > 1) ||
		// invalid temperature values
		(flags.Temp < 0 || flags.Temp > 2) ||
		// invalid topP values
		(flags.TopP < 0 || flags.TopP > 1) ||
		// lack of /dev/tty on Windows prevents this flag combination
		(runtime.GOOS == "windows" && flags.Stdin && flags.ChatMode) ||
		// stdin set but neither used as file nor as argument
		(flags.Stdin && !(len(flag.Args()) == 1 && flag.Args()[0] == "-") && !oneMatches(flags.FilePaths, "-")) ||
		// one of file or argument as system instruction - look for a prompt
		(flags.SystemInstruction &&
			// no stdin, no argument
			((!flags.Stdin && len(flag.Args()) == 0) ||
				// no stdin, argument as system instruction, no prompt as file, no chat mode
				(!flags.Stdin && len(flag.Args()) > 0 && !anyMatches(flags.FilePaths, pExt) && !flags.ChatMode) ||
				// stdin as file, no prompt as file or argument
				(flags.Stdin && oneMatches(flags.FilePaths, "-") && len(flag.Args()) == 0 && !oneMatches(flags.FilePaths, pExt)) ||
				// stdin as argument, no prompt as file
				(flags.Stdin && len(flag.Args()) == 1 && flag.Args()[0] == "-" && !oneMatches(flags.FilePaths, pExt) && !flags.ChatMode))) {
		return false
	}
	return true
}
